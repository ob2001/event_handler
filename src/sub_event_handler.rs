use std::fmt::Debug;
use crate::{Event, LiRC};

// Todo
// Event handler reporting to a parent object
#[derive(Debug)]
pub struct SubEventHandler<T, Ev: Event> where 
    LiRC<Ev>: Debug {
    stack: Vec<Ev>,
    prev_event: Option<Ev>,
    listeners: Vec<LiRC<Ev>>,
    parent: Option<T>,
}

impl<T, Ev: Event> SubEventHandler<T, Ev> where
    LiRC<Ev>: Debug{
    pub fn new(parent: Option<T>) -> Self {
        SubEventHandler { 
            stack: Vec::new(),
            prev_event: None,
            listeners: Vec::new(),
            parent
        }
    }

    pub fn push_event(&mut self, event: Option<Ev>) {
        match event {
            Some(e) => {
                #[cfg(debug_assertions)]
                println!("Event pushed to stack: {:?}", e);

                self.stack.push(e)
            },
            _ => {}
        }
    }

    pub fn push_events(&mut self, events: Option<Vec<Ev>>) {
        match events {
            None => {}
            Some(e) => {
                #[cfg(debug_assertions)]
                println!("Events pushed to stack: {:?}", e);

                self.stack.extend(e);
            }
        }
    }

    pub fn get_stack(&self) -> &Vec<Ev> {
        &self.stack
    }

    pub fn get_listeners(&self) -> Vec<LiRC<Ev>> {
        // todo
        vec![]
    }

    pub fn peek_next_event(&self) -> Option<&Ev> {
        #[cfg(debug_assertions)]
        println!("Event peeked: {:?}", self.stack.first());

        self.stack.first()
    }

    pub fn pop_next_event(&mut self) -> Option<Ev> {
        let ret = self.stack.pop();
        #[cfg(debug_assertions)]
        println!("Event popped: {:?}", ret);

        self.prev_event = ret.clone();
        ret
    }

    pub fn get_prev_event(&self) -> &Option<Ev> {
        &self.prev_event
    }

    pub fn consume_next_event(&mut self) {
        let next = self.pop_next_event();

        match next {
            Some(e) => {
                #[cfg(debug_assertions)]
                println!("Consumed event: {:?}", e);

                self.broadcast_event(e);
            }
            None => ()
        }
    }

    pub fn broadcast_event(&mut self, event: Ev) {
        let mut new_events = vec![];

        #[cfg(debug_assertions)]
        println!("Broadcast event: {:?}", event);

        for li in self.get_listeners() {
            if li.borrow().get_triggers().contains(&&event) {
                new_events.extend(li.borrow().on_triggers(vec![&&event]).unwrap_or_default());
            }
        }

        #[cfg(debug_assertions)]
        println!("Events generated by listeners: {:?}", new_events);

        self.push_events(Some(new_events));
    }

    pub fn broadcast_events(&self, events: Vec<Ev>) {
        for e in events {
            for li in self.get_listeners() {
                if li.borrow().get_triggers().contains(&&e) {
                    todo!();
                }
            }
        }
    }
}